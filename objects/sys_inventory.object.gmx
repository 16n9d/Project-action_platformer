<!--This Document is generated by GameMaker, if you edit it by hand then you do so at your own risk!-->
<object>
  <spriteName>mask_system</spriteName>
  <solid>0</solid>
  <visible>-1</visible>
  <depth>-2000</depth>
  <persistent>-1</persistent>
  <parentName>&lt;undefined&gt;</parentName>
  <maskName>mask_solid</maskName>
  <events>
    <event eventtype="0" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>/// Create the item enumerator
enum item {
    delete  = -1,
    null    = 0,
    potion  = 1,
    mpotion = 2,
    bomb    = 3,
    key     = 4 
}

</string>
          </argument>
        </arguments>
      </action>
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>/// Initialize the inventory object
width  = 5;
height = 8;
bsize  = 34;

xx = view_xview;

// Create the ds_grid
// Items
slot = ds_grid_create(width, height);
ds_grid_clear(slot, item.null);

// Item count
count = ds_grid_create(width, height);
ds_grid_clear(count, 0);

hold   = false;
hold_i = noone;
hold_n = 0;
hold_obj = noone;

show   = false;
desc   = " ";
tobj   = noone;
obj    = noone;
a_gpd  = "take item";
b_gpd  = "take one";
x_gpd  = " - ";

/// Set locked spaces
slot[# 0,0] = NULL; slot[# 4,0] = NULL; slot[# 0,7] = NULL;
slot[# 1,7] = NULL; slot[# 3,7] = NULL; slot[# 4,7] = NULL;
slot[# 2,7] = item.delete;

count[# 0,0] = NULL; count[# 4,0] = NULL; count[# 0,7] = NULL;
count[# 1,7] = NULL; count[# 3,7] = NULL; count[# 4,7] = NULL;

inv_pickup(item.potion, 4);
inv_pickup(item.bomb, 9);
inv_pickup(item.key, 6);
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="3" enumb="2">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>/// Controll the inventory 
// Follow the view ********************************************************************

// Check if inventory is open And if player is not dead
if (show) {
    // Stop the player from moving and open the inventory
    if (instance_exists(obj_player)) {
        obj_player.movement = false
        x += ((view_xview + view_hview + 128) - x) * 0.2;
    } else {
        x += ((view_xview + view_hview + 416) - x) * 0.2;
    }
    
    xx += (view_xview - xx) * 0.2;
} else {
    // Close the inventory
    if (instance_exists(obj_player)) obj_player.movement = true; 
    
    x += ((view_xview + view_hview + 424) - x) * 0.2;
    xx += ((view_xview - sprite_get_width(spr_menu) - 24) - xx) * 0.2;
}

// Follow the view from y
y += ((view_yview + 96) - y) * 1.0;

// Check for gamepad *****************************************************************

// Change main variables depending if playing with gamepad
if (global.gamepad) {
    gx = xtogx(sys_selector.x);
    gy = ytogy(sys_selector.y);
} else {
    gx = xtogx(mouse_x);
    gy = ytogy(mouse_y);
    
}

// Current item system ****************************************************************

// Give current item variables
for (i = 0 ; i &lt; 3 ; i++) {
    inv[i, 0] = slot  [# i + 1, 0];
    inv[i, 1] = obj;
    inv[i, 2] = count [# i + 1, 0];
}

// Manage the inventory system (Primary action)****************************************

// Controll the movement arround the inventory
// Check if key_primaaction was done an inventory was open
if ( key_prima &amp;&amp; show) {
    if (slot[# gx, gy] != NULL ) {
        if (slot[# gx, gy] != item.null &amp;&amp; !hold &amp;&amp; slot[# gx, gy] != item.delete) {
            // Grab something when click
            hold = true;
            hold_n = count[# gx, gy];   
            hold_i = inv_empty(gx, gy);
            hold_obj = tobj;
        } else {
            // Check if the user has grabbed something
            if (hold) {
                // Return item to it's last place if key_primaoutside the grid
                if (gx != median(0, gx, width - 1) || gy != median(0, gy, height -1)) {
                    with(par_solid) {
                        if (distance_to_point(mouse_x, mouse_y) &gt; 2 &amp;&amp; sys_inventory.hold == true) {
                            repeat(sys_inventory.hold_n) {
                                var i0 = instance_create(mouse_x, mouse_y, sys_inventory.hold_obj);
                                    i0.mspd = choose(-1, 1);
                            }
                            sys_inventory.hold = false;
                        }
                    }
                    hold = false;
                    hold_i = noone;
                    hold_n = 0;
                    hold_obj = noone;
                } else {
                    if (slot[# gx, gy] == item.null) {
                        // Leave a item if there's a free space
                        slot[# gx, gy] = hold_i;
                        count[# gx, gy] = hold_n;
                        hold = false;
                        hold_i = noone;
                        hold_obj = noone;
                        hold_n = 0;
                    } else if (slot[# gx, gy] == hold_i &amp;&amp; count[# gx, gy] &lt; 9 &amp;&amp; hold_n &lt; 9 || slot[# gx, gy] == hold_i) {
                        // Add amount if the target slot is the same item as the one stored
                        if (count[# gx, gy] + hold_n &lt;= 9) {
                            count[# gx, gy] += hold_n;
                            hold = false;
                            hold_n = 0;
                            hold_i = noone;
                            hold_obj = noone;
                        } else {
                            hold_n -= (9 - count[# gx, gy]);
                            count[# gx, gy] += (9 - count[# gx, gy]);
                        }
                    } else if (slot[# gx, gy] != hold_i &amp;&amp; slot[# gx, gy] != item.null) {
                        if (slot[# gx, gy] != item.delete) {
                            var aux_n, aux_i;
                                aux_n = hold_n;
                                aux_i = hold_i;
                                
                            hold_i = slot[# gx, gy];
                            hold_n = count[# gx, gy];
                            hold_obj = tobj;
                            
                            slot[# gx, gy]  = aux_i;
                            count[# gx, gy] = aux_n;            
                        } else {
                            hold   = false;
                            hold_i = noone;
                            hold_obj = noone;
                            hold_n = 0;
                        }    
                    }   
                }
            }
        }
    }
} else if (key_second &amp;&amp; show) {
    
    // Secondary action ****************************************************************

    if (slot[# gx, gy] != item.null &amp;&amp; slot[# gx, gy] != NULL) {
        if (!hold &amp;&amp; slot[# gx, gy] != item.delete){
            hold = true;
            hold_i = slot[# gx, gy];
            hold_obj = tobj;
            hold_n++;
            
            inv_delete(gx, gy, 1);
        } else if (slot[# gx, gy] == hold_i &amp;&amp; hold &amp;&amp; hold_n &lt; 9) {
            hold_n++;
            
            inv_delete(gx, gy, 1);
        }
    } else if (hold &amp;&amp; slot[# gx, gy] != NULL) {
        if (gx != median(0, gx, width - 1) || gy != median(0, gy, height -1)) {
            inv_pickup(hold_i, hold_n);
            hold = false;
            hold_i = noone;
            hold_obj = noone;
            hold_n = 0;
        } else {
            if (slot[# gx, gy] == item.null) {
                inv_add(gx, gy, hold_i, 1);
                if (hold_n &gt; 1) {
                    hold_n--;
                } else {
                    hold = false;
                    hold_i = noone;
                    hold_obj = noone;
                    hold_n = 0;
                }
            }
        }
    }
}

if (hold &amp;&amp; !show) {
    inv_pickup(hold_i, hold_n);
    hold = false;
    hold_i = noone;
    hold_n = 0; 
}

if (key_drop &amp;&amp; show) {
    if (!hold &amp;&amp; slot[# gx, gy] != NULL &amp;&amp; slot[# gx, gy] != item.delete) {
        repeat(count[# gx, gy]) {
            var i1 = instance_create(obj_player.x, obj_player.y - 16, tobj);
                i1.mspd = 0.75 * obj_player.dir;
                i1.alarm[0] = 30;
                i1.can_take = false;
        }
        inv_empty(gx, gy);
    } else {
        repeat(hold_n) {
            var i2 = instance_create(obj_player.x, obj_player.y - 16, hold_obj);
                i2.mspd = 0.75 * obj_player.dir;
                i2.alarm[0] = 30;
                i2.can_take = false;
        }
            
        hold = false;
        hold_i = noone;
        hold_n = 0;
        hold_obj = noone;
    }
}
// Show messages for the gamepad buttons if gamepad enabled **************************

if (hold &amp;&amp; slot[# gx, gy] != NULL &amp;&amp; slot[# gx, gy] != item.null) {
    if (slot[# gx, gy] == hold_i) {
        if (count[# gx, gy] &lt; 9 &amp;&amp; hold_n &lt; 9) {
            b_gpd = "take one";
            a_gpd = "leave item";
            x_gpd = "drop hold item";
        } else if (hold_n &lt; 9){
            b_gpd = "take one";
            a_gpd = " - ";
            x_gpd = "drop hold item";
        } else {
            a_gpd = "leave item";
            b_gpd = " - ";
            x_gpd = "drop hold item";
        }
    } else {
        a_gpd = "swap";
        b_gpd = " - ";
        x_gpd = "drop hold item";
    }
} else {
    if (!hold) {
        if (slot[# gx, gy] == item.null) {
            a_gpd = " - ";
            b_gpd = " - ";
            x_gpd = " - ";
        } else {
            b_gpd = "take one";
            a_gpd = "take item";
            x_gpd = "drop item";
        }
    } else if (hold &amp;&amp; slot[# gx, gy] == item.null){
        a_gpd = "leave item";
        b_gpd = "leave one";
        x_gpd = "drop hold item";
    }
}

if (slot[# gx, gy] == item.delete &amp;&amp; hold) {
    a_gpd = "destroy";
    b_gpd = " - ";
} else if (slot[# gx, gy] == NULL || slot[# gx, gy] == item.delete &amp;&amp; !hold) {
    a_gpd = " - ";
    b_gpd = " - ";  
}

// Default variables ******************************************************************

x = round(x);
y = round(y);
</string>
          </argument>
        </arguments>
      </action>
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>/// Show item descriptions
if (!hold) {
    switch(slot[# gx, gy]) {
        case 1:  desc = "Potion, cures 25% HP#(consumable)"; break;
        case 3:  desc = "Bomb, it explodes#(usable)";        break;
        case 4:  desc = "Key, open basic locks#(key item)";  break;
        default: desc = " "; break;
    }
} else {
    switch(hold_i) {
        case 1:  desc = "Potion, cures 25% HP#(consumable)"; break;
        case 3:  desc = "Bomb, it explodes#(usable)";        break;
        case 4:  desc = "Key, open basic locks#(key item)";  break;
        default: desc = " "; break;
    }
}

switch(slot[# sys_camera.pos + 1, 0]) {
    case 1:  obj = obj_potion; break;
    case 3:  obj = obj_bomb;   break;
    case 4:  obj = obj_key;    break;
    default: obj = noone; break;
}

switch(slot[# gx, gy]) {
    case 1:  tobj = obj_potion; break;
    case 3:  tobj = obj_bomb;   break;
    case 4:  tobj = obj_key;    break;
    default: tobj = noone; break;
}
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="8" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>/// Draw the inventory
// Draw the inventory *********************************************************************************************
// Draw the base
draw_sprite_ext(spr_inventory, global.gamepad, x, view_yview + 96,1,1,0,c_white, 0.80);
draw_sprite_ext(spr_menu, 0, 0 + xx, view_yview + 96, 1, 1, 0, c_white, 0.80);

// Set a cord for all the slots ***********************************************************************************
for (var _yy = 0 ; _yy &lt; height ; _yy++) {
    for (var _xx = 0; _xx &lt; width; _xx++) {
        var tx, ty;
            tx = x + (_xx * bsize);
            ty = (view_yview + 96) + (_yy * bsize);
        
        draw_sprite(spr_item, slot[# _xx, _yy], tx, ty);
        if (count[# _xx, _yy] &gt; 0) {
            draw_set_font(fnt_game);
            if (count[# _xx, _yy] &lt; 9) {
                draw_text_colour(tx+22, ty+20, count[# _xx, _yy], c_white, c_white, c_white, c_white, 1);
            } else {
                draw_text_colour(tx+22, ty+20, count[# _xx, _yy], c_orange, c_orange, c_orange, c_orange, 1);
            }
        }
    }
}

// Compatibility with gamepad **************************************************************************************
if (hold) {
    if (global.gamepad) {
        draw_sprite_ext(spr_item, hold_i, sys_selector.x - 14, sys_selector.y - 20, 1.25, 1.25, 0, c_white, 1);
        draw_set_font(fnt_game);
        if (hold_n &lt; 9) {
            draw_text_colour(sys_selector.x+12, sys_selector.y+12, hold_n, c_white, c_white, c_white, c_white, 1);
        } else {
            draw_text_colour(sys_selector.x+12, sys_selector.y+12, hold_n, c_orange, c_orange, c_orange, c_orange, 1);
        } 
    } else {
        draw_sprite(spr_item, hold_i, mouse_x, mouse_y);
        draw_set_font(fnt_game);
        if (hold_n &lt; 9) {
            draw_text_colour(mouse_x+22, mouse_y+20, hold_n, c_white, c_white, c_white, c_white, 1);
        } else {
            draw_text_colour(mouse_x+22, mouse_y+20, hold_n, c_orange, c_orange, c_orange, c_orange, 1);
        }
    }
}

var key_show = gamepad_button_check_pressed(0, gp_start) || keyboard_check_pressed(vk_enter);

if (key_show &amp;&amp; !show) {
    show = true;
} else if (key_show &amp;&amp; show) {
    show = false;
}

if (show) {
    draw_set_colour(c_white);
    draw_set_font(fnt_game);
    draw_set_halign(fa_center);
    draw_text(x + 78, (view_yview + 96) + 292, desc);
    draw_set_halign(fa_left);
}

if (global.gamepad) {
    draw_set_colour(c_white);
    draw_set_font(fnt_game);
    draw_set_halign(fa_left);
    draw_text(x - 32, (view_yview + 96) - 86, a_gpd);
    draw_text(x + 108, (view_yview + 96) - 86, b_gpd);
    draw_text(x - 32, (view_yview + 96) - 60, x_gpd);
}

</string>
          </argument>
        </arguments>
      </action>
    </event>
  </events>
  <PhysicsObject>0</PhysicsObject>
  <PhysicsObjectSensor>0</PhysicsObjectSensor>
  <PhysicsObjectShape>0</PhysicsObjectShape>
  <PhysicsObjectDensity>0.5</PhysicsObjectDensity>
  <PhysicsObjectRestitution>0.100000001490116</PhysicsObjectRestitution>
  <PhysicsObjectGroup>0</PhysicsObjectGroup>
  <PhysicsObjectLinearDamping>0.100000001490116</PhysicsObjectLinearDamping>
  <PhysicsObjectAngularDamping>0.100000001490116</PhysicsObjectAngularDamping>
  <PhysicsObjectFriction>0.200000002980232</PhysicsObjectFriction>
  <PhysicsObjectAwake>-1</PhysicsObjectAwake>
  <PhysicsObjectKinematic>0</PhysicsObjectKinematic>
  <PhysicsShapePoints/>
</object>
